/*
 * Copyright (c) 2013-2015 Netcrest Technologies, LLC. All rights reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.netcrest.pado.index.gemfire.service;

import java.io.DataInput;
import java.io.DataOutput;
import java.io.IOException;
import java.util.HashMap;

import com.gemstone.gemfire.DataSerializable;
import com.gemstone.gemfire.DataSerializer;
import com.netcrest.pado.index.service.GridQuery;

/**
 * <p>
 * Wrapper class for query request passed from client LocalFunction to
 * IndexMatrixServer then to data server.
 * </p>
 * <p>
 * This class contains everything required for query including the
 * <code>providerKey</code> and
 * <code>actionKey<code> to identify an <code>IndexMatrixProvider</code> and
 * query action
 * </p>
 * <p>
 * K is an actionKey for the provider to identify the pool or region required
 * for this query
 * </p>
 * <p>
 * R is a class of the result set
 * </p>
 * <p>
 * <b> Note that this implementation is not synchronized. </b>
 * </p>
 * 
 */
public class GemfireGridQuery extends GridQuery implements DataSerializable
{
	private static final long serialVersionUID = 1L;

	public GemfireGridQuery()
	{
	}

	/**
	 * Reads the state of this object from the given <code>DataInput</code>.
	 * 
	 * @gfcodegen This code is generated by gfcodegen.
	 */
	public void fromData(DataInput input) throws IOException, ClassNotFoundException
	{
		id = DataSerializer.readString(input);
		gridIds = DataSerializer.readStringArray(input);
		providerKey = DataSerializer.readString(input);
		queryString = DataSerializer.readString(input);
		fetchSize = DataSerializer.readPrimitiveInt(input);
		aggregationPageSize = DataSerializer.readPrimitiveInt(input);
		startIndex = DataSerializer.readPrimitiveInt(input);
		returnKey = DataSerializer.readPrimitiveBoolean(input);
		ordered = DataSerializer.readPrimitiveBoolean(input);
		transientQuery = DataSerializer.readPrimitiveBoolean(input);
		sortField = DataSerializer.readString(input);
		ascending = DataSerializer.readPrimitiveBoolean(input);
		sortKey = DataSerializer.readPrimitiveBoolean(input);
		parameterMap = DataSerializer.readHashMap(input);
		forceRebuildIndex = DataSerializer.readPrimitiveBoolean(input);
		throwExceptionOnExpire = DataSerializer.readPrimitiveBoolean(input);
		fullPath = DataSerializer.readString(input);
	}

	/**
	 * Writes the state of this object to the given <code>DataOutput</code>.
	 * 
	 * @gfcodegen This code is generated by gfcodegen.
	 */
	public void toData(DataOutput output) throws IOException
	{
		getId();
		DataSerializer.writeString(id, output);
		DataSerializer.writeStringArray(gridIds, output);
		DataSerializer.writeString(providerKey, output);
		DataSerializer.writeString(queryString, output);
		DataSerializer.writePrimitiveInt(fetchSize, output);
		DataSerializer.writePrimitiveInt(aggregationPageSize, output);
		DataSerializer.writePrimitiveInt(startIndex, output);
		DataSerializer.writePrimitiveBoolean(returnKey, output);
		DataSerializer.writePrimitiveBoolean(ordered, output);
		DataSerializer.writePrimitiveBoolean(transientQuery, output);
		DataSerializer.writeString(sortField, output);
		DataSerializer.writePrimitiveBoolean(ascending, output);
		DataSerializer.writePrimitiveBoolean(sortKey, output);
		DataSerializer.writeHashMap((HashMap) parameterMap, output);
		DataSerializer.writeBoolean(forceRebuildIndex, output);
		DataSerializer.writeBoolean(throwExceptionOnExpire, output);
		DataSerializer.writeString(fullPath, output);
	}

}
